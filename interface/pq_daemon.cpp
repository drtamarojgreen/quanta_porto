#include "pq_daemon.h"
#include "Config.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <filesystem>
#include <chrono>
#include <thread>
#include <sys/stat.h>

namespace fs = std::filesystem;

// --- Helper Functions for Parsing ---

static std::string trim(const std::string& str) {
    const std::string whitespace = " \t\n\r\f\v";
    size_t first = str.find_first_not_of(whitespace);
    if (std::string::npos == first) {
        return "";
    }
    size_t last = str.find_last_not_of(whitespace);
    return str.substr(first, (last - first + 1));
}

static std::string get_tag_content(const std::string& xml, const std::string& tag, size_t& pos) {
    std::string start_tag = "<" + tag + ">";
    std::string end_tag = "</" + tag + ">";
    size_t start = xml.find(start_tag, pos);
    if (start == std::string::npos) {
        return "";
    }
    start += start_tag.length();
    size_t end = xml.find(end_tag, start);
    if (end == std::string::npos) {
        return "";
    }
    pos = end + end_tag.length();
    return xml.substr(start, end - start);
}

static std::vector<std::string> get_all_tag_contents(const std::string& xml, const std::string& tag) {
    std::vector<std::string> contents;
    std::string start_tag = "<" + tag + ">";
    std::string end_tag = "</" + tag + ">";
    size_t pos = 0;
    while ((pos = xml.find(start_tag, pos)) != std::string::npos) {
        pos += start_tag.length();
        size_t end = xml.find(end_tag, pos);
        if (end == std::string::npos) {
            break;
        }
        contents.push_back(trim(xml.substr(pos, end - pos)));
        pos = end + end_tag.length();
    }
    return contents;
}

// --- PQL Parser ---

std::vector<PQLTask> PQLParser::parse(const std::string& filename) {
    std::vector<PQLTask> tasks;
    std::ifstream file(filename);
    if (!file.is_open()) {
        // Silently fail, scheduler will handle the error.
        return tasks;
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string xml_content = buffer.str();

    size_t pos = 0;
    while ((pos = xml_content.find("<task", pos)) != std::string::npos) {
        size_t end_of_task_tag = xml_content.find(">", pos);
        size_t end_of_task = xml_content.find("</task>", pos);
        if (end_of_task_tag == std::string::npos || end_of_task == std::string::npos) {
            break;
        }

        std::string task_attributes = xml_content.substr(pos, end_of_task_tag - pos);
        std::string task_inner_xml = xml_content.substr(end_of_task_tag + 1, end_of_task - (end_of_task_tag + 1));

        PQLTask task;

        std::string temp = task_attributes;
        std::replace(temp.begin(), temp.end(), '=', ' ');
        std::replace(temp.begin(), temp.end(), '"', ' ');
        std::stringstream ss(temp);
        std::string key, value;
        ss >> key; // <task
        while(ss >> key >> value) {
            if (key == "id") task.id = value;
            else if (key == "type") task.type = value;
            else if (key == "priority") task.priority = value;
            else if (key == "status") task.status = value;
            else if (key == "created") task.created = value;
        }

        size_t inner_pos = 0;
        task.description = trim(get_tag_content(task_inner_xml, "description", inner_pos));
        std::string commands_xml = get_tag_content(task_inner_xml, "commands", inner_pos);
        task.commands = get_all_tag_contents(commands_xml, "command");
        std::string criteria_xml = get_tag_content(task_inner_xml, "criteria", inner_pos);
        task.criteria = get_all_tag_contents(criteria_xml, "criterion");
        task.notes = trim(get_tag_content(task_inner_xml, "notes", inner_pos));

        tasks.push_back(task);
        pos = end_of_task + std::string("</task>").length();
    }
    return tasks;
}

// --- Action Script Generator ---

bool ActionScriptGenerator::generate(const Config& config, const PQLTask& task) {
    auto actions_pending_dir_opt = config.getString("ACTIONS_PENDING_DIR");
    if (!actions_pending_dir_opt) {
        std::cerr << "Error: ACTIONS_PENDING_DIR not set in config." << std::endl;
        return false;
    }

    fs::path action_script_path = fs::path(*actions_pending_dir_opt) / (task.id + ".sh");

    std::ofstream out_file(action_script_path);
    if (!out_file) {
        std::cerr << "Error: Could not create action script: " << action_script_path << std::endl;
        return false;
    }

    out_file << "#!/bin/bash" << std::endl;
    out_file << "# Action script for task: " << task.id << std::endl;
    out_file << "# Generated by QuantaPorto C++ Daemon" << std::endl;
    out_file << "set -e" << std::endl << std::endl;

    for (const auto& command : task.commands) {
        out_file << command << std::endl;
    }
    out_file.close();

    if (chmod(action_script_path.c_str(), S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) != 0) {
        std::cerr << "Error: Could not set executable permissions on " << action_script_path << std::endl;
        return false;
    }

    std::cout << "Info: Successfully created action script: " << action_script_path.string() << std::endl;
    return true;
}

// --- Scheduler ---

void Scheduler::run(const Config& config) {
    auto pending_dir_opt = config.getString("QUEUE_PENDING_DIR");
    auto in_progress_dir_opt = config.getString("QUEUE_IN_PROGRESS_DIR");
    auto failed_dir_opt = config.getString("QUEUE_FAILED_DIR");
    auto poll_interval_opt = config.getInt("POLL_INTERVAL_SEC");

    if (!pending_dir_opt || !in_progress_dir_opt || !failed_dir_opt || !poll_interval_opt) {
        std::cerr << "Error: Queue directories or poll interval not fully configured." << std::endl;
        return;
    }

    fs::path pending_dir = *pending_dir_opt;
    fs::path in_progress_dir = *in_progress_dir_opt;
    fs::path failed_dir = *failed_dir_opt;

    fs::create_directories(pending_dir);
    fs::create_directories(in_progress_dir);
    fs::create_directories(failed_dir);

    std::cout << "Info: QuantaPorto C++ Daemon started." << std::endl;
    std::cout << "Info: Monitoring queue: " << pending_dir.string() << std::endl;

    while (true) {
        fs::path task_file;
        bool found_task = false;
        for (const auto& entry : fs::directory_iterator(pending_dir)) {
            if (entry.is_regular_file()) {
                task_file = entry.path();
                found_task = true;
                break;
            }
        }

        if (!found_task) {
            std::this_thread::sleep_for(std::chrono::seconds(*poll_interval_opt));
            continue;
        }

        fs::path in_progress_path = in_progress_dir / task_file.filename();

        try {
            fs::rename(task_file, in_progress_path);
            std::cout << "Info: Moved task to in-progress: " << in_progress_path.string() << std::endl;
        } catch (const fs::filesystem_error& e) {
            std::cerr << "Error: Failed to move task file '" << task_file.string() << "': " << e.what() << std::endl;
            continue;
        }

        PQLParser parser;
        std::vector<PQLTask> tasks = parser.parse(in_progress_path.string());

        if (tasks.empty() || tasks[0].id.empty()) {
            std::cerr << "Error: Failed to parse task file or file is empty: " << in_progress_path.string() << std::endl;
            fs::rename(in_progress_path, failed_dir / in_progress_path.filename());
            continue;
        }

        const PQLTask& current_task = tasks[0];

        ActionScriptGenerator generator;
        if (generator.generate(config, current_task)) {
            // Task successfully dispatched
        } else {
            std::cerr << "Error: Worker failed for task: " << current_task.id << std::endl;
            fs::rename(in_progress_path, failed_dir / in_progress_path.filename());
            std::cout << "Info: Moved task to failed queue: " << (failed_dir / in_progress_path.filename()).string() << std::endl;
        }
    }
}

// --- Placeholder Implementations ---

std::string PromptGenerator::generate(const PQLTask& task) {
    std::stringstream prompt;
    prompt << "Task: " << task.description << std::endl;
    prompt << "Commands:" << std::endl;
    for (const auto& cmd : task.commands) {
        prompt << "- " << cmd << std::endl;
    }
    prompt << "Criteria:" << std::endl;
    for (const auto& crit : task.criteria) {
        prompt << "- " << crit << std::endl;
    }
    return prompt.str();
}

std::string LLMRunner::run(const std::string& prompt) {
    std::cout << "--- Running LLM with prompt ---" << std::endl;
    std::cout << prompt << std::endl;
    std::cout << "--- End of prompt ---" << std::endl;
    return "This is a placeholder response from the LLM.";
}

bool RuleEngine::evaluate(const std::string& response) {
    std::cout << "Evaluating rules for response: " << response << std::endl;
    return true;
}

std::string ReflectionEngine::reflect(const std::string& failed_response) {
    std::cout << "Reflecting on failed response: " << failed_response << std::endl;
    return "This is a new prompt after reflection.";
}

// --- main ---

int main() {
    std::cout << "QuantaPorto C++ Daemon Initializing..." << std::endl;

    Config config;
    if (!config.load("environment.txt")) {
        std::cerr << "Failed to load 'environment.txt'. Make sure the application is run from the project root directory." << std::endl;
        return 1;
    }
    std::cout << "Configuration loaded successfully." << std::endl;

    Scheduler scheduler;
    scheduler.run(config);

    return 0; // Unreachable
}
